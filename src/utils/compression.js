/**
    Namespace for LZW compression and decompression.
    Methods:
        LZW.compress(uncompressed)
        LZW.decompress(compressed)
*/
export default class LZW {

	// https://gist.github.com/revolunet/843889?permalink_comment_id=3106373#gistcomment-3106373

	/**
	 * Compresses a string using LZW algorithm with Unicode support
	 * @param {string} s - The string to compress
	 * @returns {string} Compressed string
	 * @throws {TypeError} If input is not a string
	 */
	static compress (s) {
		if (s === undefined || s === null || typeof s !== 'string') {
			throw new TypeError('LZW compress() input must be a string');
		}
		if (s === '') return '';

		let dict = new Map(); // Use a Map!
		let data = s.split("");
		let out = [];
		let currentCharacter;
		let currentPharse = data[0];
		let code = 256;
		for (let i = 1; i < data.length; i++) {
				currentCharacter = data[i];
				if (dict.has(currentPharse + currentCharacter)) {
						currentPharse += currentCharacter;
				} else {
						out.push (currentPharse.length > 1 ? dict.get(currentPharse) : currentPharse.codePointAt(0));
						dict.set(currentPharse + currentCharacter, code);
						code++;
						if (code === 0xd800) { code = 0xe000; }
						currentPharse = currentCharacter;
				}
		}
		out.push (currentPharse.length > 1 ? dict.get(currentPharse) : currentPharse.codePointAt(0));
		//console.log ("LZW MAP SIZE", dict.size, out.slice (-50), out.length, out.join("").length);
		return String.fromCodePoint(...out)
}

	/**
		Decompress LZW string generated by LZW.encode()
		@param {string} s - LZW compression string
		@returns {string} - original string
	*/
	static decompress (s) {
		if (s === undefined || s === null || typeof s !== 'string') {
			throw new TypeError('LZW compress() input must be a string');
		}
		if (s === '') return '';

			let dict = new Map(); // Use a Map!
			let data = Array.from(s);
			if (!data.length) throw new Error(`Error processing LZW input`)

			let currentCharacter = data[0];
			let oldPhrase = currentCharacter;
			let out = [currentCharacter];
			let code = 256;
			let currentPharse;
			for (let i = 1; i < data.length; i++) {
					let currCode = data[i].codePointAt(0);
					if (currCode < 256) {
							currentPharse = data[i];
					} else {
							currentPharse = dict.has(currCode) ? dict.get(currCode) : (oldPhrase + currentCharacter);
					}
					out.push(currentPharse);
					let cp = currentPharse.codePointAt(0);
					currentCharacter = String.fromCodePoint(cp); //currentPharse.charAt(0);
					dict.set(code, oldPhrase + currentCharacter);
					code++;
					if (code === 0xd800) { code = 0xe000; }
					oldPhrase = currentPharse;
			}
			return out.join("");
	}
}
/*
let comp = LZW.compress('TOBEORNOTTOBEORTOBEORNOT');
let decomp = LZW.decompress(comp);

console.log(`${comp}
${decomp}`);
*/
